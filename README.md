# Shapey

## Preface
This was a quick project thrown together at 4 in the morning (I couldn't sleep), some bad code here and there, but this is mostly for a proof of concept, so I'm not too worried about this.

I want to (in the future) build a plugin that can arbitrarily render any .obj files (ambitious, I know... one can dream.), figured that this would be a nice starting point to get into 3d graphics.


## Quick Demo:

https://github.com/user-attachments/assets/d44a8e96-3519-4d48-8e28-2eef9f42aedd


Full video coming at a later date.

## Design & Architecture

### Shape Representation
- Each shape in the world is represented by a `ShapeInstance` object, which encapsulates geometry, transformation state, animation parameters, and rendering configuration.
- We use `ShapeManager` as a central registry and scheduler for all active `ShapeInstance` objects. Responsible for ticking and updating all shapes every server tick.
- `GeometryFactory` for generating point arrays for various geometric primitives (cube, sphere, torus, etc.) given scale, rotation, and resolution.


## Da Math

### 3D Transformations
- Each point in a shape undergoes the following sequence:
  1. **Scaling**: Points are scaled relative to the shape's origin.
  2. **Rotation**: Full 3-axis (yaw, pitch, roll) rotation is applied using Euler angles. The rotation is performed in the order: roll (Z), pitch (X), yaw (Y).
  3. **Translation**: The rotated point is translated to the shape's world position.
- **Rotation Implementation**: Rotation is implemented via explicit matrix multiplication for each axis, composed in the order above. This is mathematically equivalent to multiplying the corresponding rotation matrices.

### Morphing
- **Shape Morphing**: Morphing between two shapes is performed by linearly interpolating between corresponding points in the source and target point arrays. The interpolation parameter (`morphProgress`) is incremented each tick, allowing smooth transitions.
- **Constraint**: Morphing assumes both shapes have the same number of points and a consistent point ordering.

### Animation & Rendering Logic
- Each shape can have a per-axis angular velocity (spin velocity), stored as a 3D vector. On each tick, the current rotation vector is incremented by the spin velocity, resulting in continuous rotation.
- Each shape is rendered by spawning particles at the transformed positions of its geometry points.


## Commands To Test:

- **Commands**:
  - `/rendershape <shape> <x> <y> <z> <scale> <rotation> <resolution>`: Spawns a new shape at the specified location and size.
  - `/spinmyshape <id> <yaw> <pitch> <roll>`: Sets per-axis spin velocity.
  - `/transformtheshape <id> <targetShape>`: Morphs a shape into another geometry.
  - `/colourmyshape <id> <colour|#hex|rainbow>`: Sets the color or enables rainbow mode for colorable particles.
  - `/particleshapes <id> <particle>`: Sets the particle type for a shape.
  - `/deleteshape <id>`: Removes a shape instance.

## More Nerd Explainations

### Shape Construction

1. **Geometry Generation**
   - Each shape (e.g., cube, sphere, torus) is defined by a static method that generates a list of 3D points (`List<Vector>`) representing the shape's geometry.
   - For example, a cube is constructed by calculating the positions of its vertices and interpolating points along its edges, while a sphere is generated by iterating over latitude and longitude angles to compute surface points.
   - The resolution parameter controls the number of points, affecting the visual smoothness and density of the rendered shape.

2. **Transformation Pipeline**
   - Each point in the base geometry undergoes a transformation pipeline:
     1. **Scaling**: The point is multiplied by a scale factor, adjusting the overall size of the shape.
     2. **Rotation**: The scaled point is rotated using a composite of yaw (Y), pitch (X), and roll (Z) Euler angles. This is implemented by sequentially applying rotation matrices for each axis.
     3. **Translation**: The rotated point is offset by the shape's world position, placing it at the correct location in the game world.
   - This pipeline is applied to every point on every tick, allowing for dynamic animation and transformation.
   
   *Morphing requires point arrays of equal length and consistent ordering; more robust remapping could be implemented.*

### Particle Rendering

1. **Main Thread Scheduling**
   - All particle rendering is scheduled to run on the main server thread using Bukkit's scheduler, ensuring thread safety with the Minecraft API. Probably could be optimized by using packet based particles... too lazy to implement them right now

2. **Rendering Loop**
   - For each transformed point, a particle is spawned at the corresponding world location.
   - The particle type, color, and other options are determined by the shape's current configuration (e.g., `Particle.DUST` with a specific color).
   - For colorable particles, a `Particle.DustOptions` or similar data object is used to specify the color and size.
   - For non-colorable particles, the default particle is spawned without additional data.


### Example: Cube Shape

- The cube's geometry is generated by defining its 8 vertices and interpolating points along its 12 edges.
- Each edge is divided into segments based on the resolution, and the resulting points are stored in a list.
- On each tick, these points are transformed and rendered as described above, resulting in a persistent, animated particle shape in the world.

### Summary

- Shape construction is a process of generating a set of 3D points according to mathematical formulas for each shape type.
- Rendering is achieved by transforming these points and spawning particles at their world positions every tick, creating the illusion of a persistent, animated 3D object.


---

## References
- [PaperMC API Documentation](https://papermc.io)
- [Bukkit Particle API](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/Particle.html)
- [Linear Algebra for Computer Graphics](https://en.wikipedia.org/wiki/Linear_algebra)
- [Euler Angles](https://en.wikipedia.org/wiki/Euler_angles)
